// Code generated by goyacc -p Hephaestus -o hephaestus.org/program.go -v hephaestus.org/program.output hephaestus.org/program.y. DO NOT EDIT.

//line hephaestus.org/program.y:3

package main

import __yyfmt__ "fmt"

//line hephaestus.org/program.y:4

import (
	"bufio"
	"fmt"
	"os"
	"strings"
	"unicode"
)

var regs = make([]int, 26)
var base int

//line hephaestus.org/program.y:21
type HephaestusSymType struct {
	yys int
	val int
}

const DIGIT = 57346
const LETTER = 57347
const TYPE_VOID = 57348
const TYPE_INT = 57349
const TYPE_STRING = 57350
const UMINUS = 57351

var HephaestusToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"DIGIT",
	"LETTER",
	"TYPE_VOID",
	"TYPE_INT",
	"TYPE_STRING",
	"'|'",
	"'&'",
	"'+'",
	"'-'",
	"'*'",
	"'/'",
	"'%'",
	"UMINUS",
	"'\\n'",
	"'('",
	"')'",
	"'{'",
	"'}'",
	"'='",
}

var HephaestusStatenames = [...]string{}

const HephaestusEofCode = 1
const HephaestusErrCode = 2
const HephaestusInitialStackSize = 16

//line hephaestus.org/program.y:115
/*  start  of  programs  */

type CalcLex struct {
	s   string
	pos int
}

func (l *CalcLex) Lex(lval *HephaestusSymType) int {
	var c rune = ' '
	for c == ' ' {
		if l.pos == len(l.s) {
			return 0
		}
		c = rune(l.s[l.pos])
		l.pos += 1
	}

	if l.pos+4 < len(l.s) && c == 'v' && rune(l.s[l.pos+1]) == 'o' && rune(l.s[l.pos+2]) == 'i' && rune(l.s[l.pos+3]) == 'd' {
		l.pos += 4
		return TYPE_VOID
	} else if l.pos+3 < len(l.s) && c == 'i' && rune(l.s[l.pos+1]) == 'n' && rune(l.s[l.pos+2]) == 't' {
		l.pos += 3
		return TYPE_INT
	} else if l.pos+6 < len(l.s) && c == 's' && rune(l.s[l.pos+1]) == 't' && rune(l.s[l.pos+2]) == 'r' &&
		rune(l.s[l.pos+3]) == 'i' && rune(l.s[l.pos+4]) == 'n' && rune(l.s[l.pos+5]) == 'g' {
		l.pos += 6
		return TYPE_STRING
	}

	if unicode.IsDigit(c) {
		lval.val = int(c) - '0'
		return DIGIT
	} else if unicode.IsLower(c) {
		lval.val = int(c) - 'a'
		return LETTER
	}
	return int(c)
}

func (l *CalcLex) Error(s string) {
	fmt.Printf("syntax error: %s\n", s)
}

func Main0(filename string) {
	var fi *bufio.Reader
	if filename == "" {
		fi = bufio.NewReader(os.Stdin)
	} else {
		f, err := os.Open(filename)
		if err != nil {
			fmt.Fprintf(os.Stderr, "%v\n", err)
			return
		}
		defer f.Close()
		fi = bufio.NewReader(f)
	}

	for {
		var eqn string
		var ok bool

		fmt.Printf("equation: ")
		if eqn, ok = readline(fi); ok {
			HephaestusParse(&CalcLex{s: eqn})
		} else {
			break
		}
	}
}

func TrimSuffix(s, suffix string) string {
	if strings.HasSuffix(s, suffix) {
		s = s[:len(s)-len(suffix)]
	}
	return s
}

func readline(fi *bufio.Reader) (string, bool) {
	/*scanner := fi.NewScanner(file)
	  for scanner.Scan() {


	  }*/
	s, err := fi.ReadString('\n')
	if err != nil {
		return "", false
	}
	//fmt.Println( "line:",s,"!");
	if strings.HasSuffix(s, "\r\n") {
		s = s[:len(s)-2] + "\n"
	}
	return TrimSuffix(s, "\r"), true
}

//line yacctab:1
var HephaestusExca = [...]int8{
	-1, 1,
	1, -1,
	-2, 0,
}

const HephaestusPrivate = 57344

const HephaestusLast = 66

var HephaestusAct = [...]int8{
	4, 22, 21, 16, 17, 18, 19, 20, 26, 28,
	23, 39, 42, 41, 40, 38, 15, 30, 31, 32,
	33, 34, 35, 36, 37, 13, 5, 10, 11, 12,
	18, 19, 20, 8, 16, 17, 18, 19, 20, 7,
	22, 21, 16, 17, 18, 19, 20, 13, 27, 21,
	16, 17, 18, 19, 20, 8, 25, 14, 29, 24,
	6, 7, 3, 2, 1, 9,
}

var HephaestusPact = [...]int16{
	-1000, 21, 40, -1, 31, -12, 51, 43, 43, 54,
	-1000, -1000, -1000, -1000, -1000, -1000, 43, 43, 43, 43,
	43, 43, 43, 43, -3, -1000, -8, -1000, -1000, -1000,
	17, 17, -1000, -1000, -1000, 23, 39, 31, -5, -1000,
	-7, -9, -1000,
}

var HephaestusPgo = [...]int8{
	0, 0, 65, 64, 63, 62, 60, 59, 59, 59,
}

var HephaestusR1 = [...]int8{
	0, 3, 3, 3, 5, 6, 6, 6, 7, 8,
	8, 9, 4, 4, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 2, 2,
}

var HephaestusR2 = [...]int8{
	0, 0, 3, 3, 6, 1, 1, 1, 1, 0,
	2, 3, 1, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 2, 1, 1, 1, 2,
}

var HephaestusChk = [...]int16{
	-1000, -3, -4, -5, -1, 5, -6, 18, 12, -2,
	6, 7, 8, 4, 17, 17, 11, 12, 13, 14,
	15, 10, 9, 22, -7, 5, -1, 5, -1, 4,
	-1, -1, -1, -1, -1, -1, -1, -1, 18, 19,
	19, 20, 21,
}

var HephaestusDef = [...]int8{
	1, -2, 0, 0, 12, 23, 0, 0, 0, 24,
	5, 6, 7, 25, 2, 3, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 8, 0, 23, 22, 26,
	15, 16, 17, 18, 19, 20, 21, 13, 0, 14,
	0, 0, 4,
}

var HephaestusTok1 = [...]int8{
	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	17, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 15, 10, 3,
	18, 19, 13, 11, 3, 12, 3, 14, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 22, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 20, 9, 21,
}

var HephaestusTok2 = [...]int8{
	2, 3, 4, 5, 6, 7, 8, 16,
}

var HephaestusTok3 = [...]int8{
	0,
}

var HephaestusErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	HephaestusDebug        = 0
	HephaestusErrorVerbose = false
)

type HephaestusLexer interface {
	Lex(lval *HephaestusSymType) int
	Error(s string)
}

type HephaestusParser interface {
	Parse(HephaestusLexer) int
	Lookahead() int
}

type HephaestusParserImpl struct {
	lval  HephaestusSymType
	stack [HephaestusInitialStackSize]HephaestusSymType
	char  int
}

func (p *HephaestusParserImpl) Lookahead() int {
	return p.char
}

func HephaestusNewParser() HephaestusParser {
	return &HephaestusParserImpl{}
}

const HephaestusFlag = -1000

func HephaestusTokname(c int) string {
	if c >= 1 && c-1 < len(HephaestusToknames) {
		if HephaestusToknames[c-1] != "" {
			return HephaestusToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func HephaestusStatname(s int) string {
	if s >= 0 && s < len(HephaestusStatenames) {
		if HephaestusStatenames[s] != "" {
			return HephaestusStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func HephaestusErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !HephaestusErrorVerbose {
		return "syntax error"
	}

	for _, e := range HephaestusErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + HephaestusTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(HephaestusPact[state])
	for tok := TOKSTART; tok-1 < len(HephaestusToknames); tok++ {
		if n := base + tok; n >= 0 && n < HephaestusLast && int(HephaestusChk[int(HephaestusAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if HephaestusDef[state] == -2 {
		i := 0
		for HephaestusExca[i] != -1 || int(HephaestusExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; HephaestusExca[i] >= 0; i += 2 {
			tok := int(HephaestusExca[i])
			if tok < TOKSTART || HephaestusExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if HephaestusExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += HephaestusTokname(tok)
	}
	return res
}

func Hephaestuslex1(lex HephaestusLexer, lval *HephaestusSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(HephaestusTok1[0])
		goto out
	}
	if char < len(HephaestusTok1) {
		token = int(HephaestusTok1[char])
		goto out
	}
	if char >= HephaestusPrivate {
		if char < HephaestusPrivate+len(HephaestusTok2) {
			token = int(HephaestusTok2[char-HephaestusPrivate])
			goto out
		}
	}
	for i := 0; i < len(HephaestusTok3); i += 2 {
		token = int(HephaestusTok3[i+0])
		if token == char {
			token = int(HephaestusTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(HephaestusTok2[1]) /* unknown char */
	}
	if HephaestusDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", HephaestusTokname(token), uint(char))
	}
	return char, token
}

func HephaestusParse(Hephaestuslex HephaestusLexer) int {
	return HephaestusNewParser().Parse(Hephaestuslex)
}

func (Hephaestusrcvr *HephaestusParserImpl) Parse(Hephaestuslex HephaestusLexer) int {
	var Hephaestusn int
	var HephaestusVAL HephaestusSymType
	var HephaestusDollar []HephaestusSymType
	_ = HephaestusDollar // silence set and not used
	HephaestusS := Hephaestusrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	Hephaestusstate := 0
	Hephaestusrcvr.char = -1
	Hephaestustoken := -1 // Hephaestusrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		Hephaestusstate = -1
		Hephaestusrcvr.char = -1
		Hephaestustoken = -1
	}()
	Hephaestusp := -1
	goto Hephaestusstack

ret0:
	return 0

ret1:
	return 1

Hephaestusstack:
	/* put a state and value onto the stack */
	if HephaestusDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", HephaestusTokname(Hephaestustoken), HephaestusStatname(Hephaestusstate))
	}

	Hephaestusp++
	if Hephaestusp >= len(HephaestusS) {
		nyys := make([]HephaestusSymType, len(HephaestusS)*2)
		copy(nyys, HephaestusS)
		HephaestusS = nyys
	}
	HephaestusS[Hephaestusp] = HephaestusVAL
	HephaestusS[Hephaestusp].yys = Hephaestusstate

Hephaestusnewstate:
	Hephaestusn = int(HephaestusPact[Hephaestusstate])
	if Hephaestusn <= HephaestusFlag {
		goto Hephaestusdefault /* simple state */
	}
	if Hephaestusrcvr.char < 0 {
		Hephaestusrcvr.char, Hephaestustoken = Hephaestuslex1(Hephaestuslex, &Hephaestusrcvr.lval)
	}
	Hephaestusn += Hephaestustoken
	if Hephaestusn < 0 || Hephaestusn >= HephaestusLast {
		goto Hephaestusdefault
	}
	Hephaestusn = int(HephaestusAct[Hephaestusn])
	if int(HephaestusChk[Hephaestusn]) == Hephaestustoken { /* valid shift */
		Hephaestusrcvr.char = -1
		Hephaestustoken = -1
		HephaestusVAL = Hephaestusrcvr.lval
		Hephaestusstate = Hephaestusn
		if Errflag > 0 {
			Errflag--
		}
		goto Hephaestusstack
	}

Hephaestusdefault:
	/* default state action */
	Hephaestusn = int(HephaestusDef[Hephaestusstate])
	if Hephaestusn == -2 {
		if Hephaestusrcvr.char < 0 {
			Hephaestusrcvr.char, Hephaestustoken = Hephaestuslex1(Hephaestuslex, &Hephaestusrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if HephaestusExca[xi+0] == -1 && int(HephaestusExca[xi+1]) == Hephaestusstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			Hephaestusn = int(HephaestusExca[xi+0])
			if Hephaestusn < 0 || Hephaestusn == Hephaestustoken {
				break
			}
		}
		Hephaestusn = int(HephaestusExca[xi+1])
		if Hephaestusn < 0 {
			goto ret0
		}
	}
	if Hephaestusn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			Hephaestuslex.Error(HephaestusErrorMessage(Hephaestusstate, Hephaestustoken))
			Nerrs++
			if HephaestusDebug >= 1 {
				__yyfmt__.Printf("%s", HephaestusStatname(Hephaestusstate))
				__yyfmt__.Printf(" saw %s\n", HephaestusTokname(Hephaestustoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for Hephaestusp >= 0 {
				Hephaestusn = int(HephaestusPact[HephaestusS[Hephaestusp].yys]) + HephaestusErrCode
				if Hephaestusn >= 0 && Hephaestusn < HephaestusLast {
					Hephaestusstate = int(HephaestusAct[Hephaestusn]) /* simulate a shift of "error" */
					if int(HephaestusChk[Hephaestusstate]) == HephaestusErrCode {
						goto Hephaestusstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if HephaestusDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", HephaestusS[Hephaestusp].yys)
				}
				Hephaestusp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if HephaestusDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", HephaestusTokname(Hephaestustoken))
			}
			if Hephaestustoken == HephaestusEofCode {
				goto ret1
			}
			Hephaestusrcvr.char = -1
			Hephaestustoken = -1
			goto Hephaestusnewstate /* try again in the same state */
		}
	}

	/* reduction by production Hephaestusn */
	if HephaestusDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", Hephaestusn, HephaestusStatname(Hephaestusstate))
	}

	Hephaestusnt := Hephaestusn
	Hephaestuspt := Hephaestusp
	_ = Hephaestuspt // guard against "declared and not used"

	Hephaestusp -= int(HephaestusR2[Hephaestusn])
	// Hephaestusp is now the index of $0. Perform the default action. Iff the
	// reduced production is ε, $1 is possibly out of range.
	if Hephaestusp+1 >= len(HephaestusS) {
		nyys := make([]HephaestusSymType, len(HephaestusS)*2)
		copy(nyys, HephaestusS)
		HephaestusS = nyys
	}
	HephaestusVAL = HephaestusS[Hephaestusp+1]

	/* consult goto table to find next state */
	Hephaestusn = int(HephaestusR1[Hephaestusn])
	Hephaestusg := int(HephaestusPgo[Hephaestusn])
	Hephaestusj := Hephaestusg + HephaestusS[Hephaestusp].yys + 1

	if Hephaestusj >= HephaestusLast {
		Hephaestusstate = int(HephaestusAct[Hephaestusg])
	} else {
		Hephaestusstate = int(HephaestusAct[Hephaestusj])
		if int(HephaestusChk[Hephaestusstate]) != -Hephaestusn {
			Hephaestusstate = int(HephaestusAct[Hephaestusg])
		}
	}
	// dummy call; replaced with literal code
	switch Hephaestusnt {

	case 4:
		HephaestusDollar = HephaestusS[Hephaestuspt-6 : Hephaestuspt+1]
//line hephaestus.org/program.y:48
		{
			fmt.Printf("funct\n")
		}
	case 11:
		HephaestusDollar = HephaestusS[Hephaestuspt-3 : Hephaestuspt+1]
//line hephaestus.org/program.y:64
		{
			fmt.Printf("affect %s = %s\n", HephaestusDollar[1].val, HephaestusDollar[3].val)
		}
	case 12:
		HephaestusDollar = HephaestusS[Hephaestuspt-1 : Hephaestuspt+1]
//line hephaestus.org/program.y:70
		{
			fmt.Printf("%d\n", HephaestusDollar[1].val)
		}
	case 13:
		HephaestusDollar = HephaestusS[Hephaestuspt-3 : Hephaestuspt+1]
//line hephaestus.org/program.y:74
		{
			regs[HephaestusDollar[1].val] = HephaestusDollar[3].val
		}
	case 14:
		HephaestusDollar = HephaestusS[Hephaestuspt-3 : Hephaestuspt+1]
//line hephaestus.org/program.y:80
		{
			HephaestusVAL.val = HephaestusDollar[2].val
		}
	case 15:
		HephaestusDollar = HephaestusS[Hephaestuspt-3 : Hephaestuspt+1]
//line hephaestus.org/program.y:82
		{
			HephaestusVAL.val = HephaestusDollar[1].val + HephaestusDollar[3].val
		}
	case 16:
		HephaestusDollar = HephaestusS[Hephaestuspt-3 : Hephaestuspt+1]
//line hephaestus.org/program.y:84
		{
			HephaestusVAL.val = HephaestusDollar[1].val - HephaestusDollar[3].val
		}
	case 17:
		HephaestusDollar = HephaestusS[Hephaestuspt-3 : Hephaestuspt+1]
//line hephaestus.org/program.y:86
		{
			HephaestusVAL.val = HephaestusDollar[1].val * HephaestusDollar[3].val
		}
	case 18:
		HephaestusDollar = HephaestusS[Hephaestuspt-3 : Hephaestuspt+1]
//line hephaestus.org/program.y:88
		{
			HephaestusVAL.val = HephaestusDollar[1].val / HephaestusDollar[3].val
		}
	case 19:
		HephaestusDollar = HephaestusS[Hephaestuspt-3 : Hephaestuspt+1]
//line hephaestus.org/program.y:90
		{
			HephaestusVAL.val = HephaestusDollar[1].val % HephaestusDollar[3].val
		}
	case 20:
		HephaestusDollar = HephaestusS[Hephaestuspt-3 : Hephaestuspt+1]
//line hephaestus.org/program.y:92
		{
			HephaestusVAL.val = HephaestusDollar[1].val & HephaestusDollar[3].val
		}
	case 21:
		HephaestusDollar = HephaestusS[Hephaestuspt-3 : Hephaestuspt+1]
//line hephaestus.org/program.y:94
		{
			HephaestusVAL.val = HephaestusDollar[1].val | HephaestusDollar[3].val
		}
	case 22:
		HephaestusDollar = HephaestusS[Hephaestuspt-2 : Hephaestuspt+1]
//line hephaestus.org/program.y:96
		{
			HephaestusVAL.val = -HephaestusDollar[2].val
		}
	case 23:
		HephaestusDollar = HephaestusS[Hephaestuspt-1 : Hephaestuspt+1]
//line hephaestus.org/program.y:98
		{
			HephaestusVAL.val = regs[HephaestusDollar[1].val]
		}
	case 25:
		HephaestusDollar = HephaestusS[Hephaestuspt-1 : Hephaestuspt+1]
//line hephaestus.org/program.y:103
		{
			HephaestusVAL.val = HephaestusDollar[1].val
			if HephaestusDollar[1].val == 0 {
				base = 8
			} else {
				base = 10
			}
		}
	case 26:
		HephaestusDollar = HephaestusS[Hephaestuspt-2 : Hephaestuspt+1]
//line hephaestus.org/program.y:112
		{
			HephaestusVAL.val = base*HephaestusDollar[1].val + HephaestusDollar[2].val
		}
	}
	goto Hephaestusstack /* stack new state and value */
}
